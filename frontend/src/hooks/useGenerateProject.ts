import { useState, useCallback } from 'react';
import { useMutation } from '@tanstack/react-query';
import { api, GenerateResult, GeneratedFile } from '@/lib/api';
import { useProjectStore } from '@/stores/projectStore';
import { logGeneration } from '@/lib/stripe';
import { AIModel } from '@/lib/ai';

interface UseGenerateProjectOptions {
  onSuccess?: (result: GenerateResult) => void;
  onError?: (error: Error) => void;
  streaming?: boolean;
  demoMode?: boolean;
  model?: AIModel;
  apiKey?: string; // User's own API key
  apiKeyProvider?: 'google' | 'openai' | 'anthropic' | 'custom'; // Provider of user's API key
  autoSelectKey?: boolean; // Whether to auto-select working key
  userId?: string; // User ID for auto-key selection
}

interface GenerationProgress {
  stage: 'analyzing' | 'generating' | 'building' | 'complete';
  message: string;
  progress: number;
  currentFile?: string;
}

// Demo files for showcase without backend
const generateDemoFiles = (prompt: string): GeneratedFile[] => {
  const appName = prompt.toLowerCase().includes('fitness') ? 'FitnessApp' : 
                  prompt.toLowerCase().includes('social') ? 'SocialApp' :
                  prompt.toLowerCase().includes('calculator') ? 'CalculatorApp' :
                  prompt.toLowerCase().includes('калькулятор') ? 'CalculatorApp' :
                  prompt.toLowerCase().includes('соц') ? 'SocialApp' : 'MyApp';
  
  return [
    {
      path: 'App.tsx',
      type: 'typescript',
      content: `import React from 'react';
import { NavigationContainer } from '@react-navigation/native';
import { createNativeStackNavigator } from '@react-navigation/native-stack';
import { StatusBar } from 'expo-status-bar';
import HomeScreen from './screens/HomeScreen';
import DetailsScreen from './screens/DetailsScreen';

const Stack = createNativeStackNavigator();

export default function App() {
  return (
    <NavigationContainer>
      <StatusBar style="light" />
      <Stack.Navigator
        screenOptions={{
          headerStyle: { backgroundColor: '#10b981' },
          headerTintColor: '#fff',
        }}
      >
        <Stack.Screen name="Home" component={HomeScreen} />
        <Stack.Screen name="Details" component={DetailsScreen} />
      </Stack.Navigator>
    </NavigationContainer>
  );
}`
    },
    {
      path: 'screens/HomeScreen.tsx',
      type: 'typescript',
      content: `import React from 'react';
import { View, Text, StyleSheet, TouchableOpacity, ScrollView } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';
import { Ionicons } from '@expo/vector-icons';

export default function HomeScreen({ navigation }) {
  return (
    <SafeAreaView style={styles.container}>
      <ScrollView showsVerticalScrollIndicator={false}>
        <View style={styles.header}>
          <Text style={styles.greeting}>Good morning</Text>
          <Text style={styles.title}>${appName}</Text>
        </View>
        
        <View style={styles.cardContainer}>
          <TouchableOpacity 
            style={styles.card}
            onPress={() => navigation.navigate('Details')}
          >
            <Ionicons name="sparkles" size={32} color="#10b981" />
            <Text style={styles.cardTitle}>Get Started</Text>
            <Text style={styles.cardDesc}>Tap to explore features</Text>
          </TouchableOpacity>
        </View>
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0a0a0b',
  },
  header: {
    padding: 24,
  },
  greeting: {
    fontSize: 16,
    color: '#6b7280',
  },
  title: {
    fontSize: 32,
    fontWeight: 'bold',
    color: '#ffffff',
    marginTop: 4,
  },
  cardContainer: {
    padding: 16,
  },
  card: {
    backgroundColor: '#1f1f23',
    borderRadius: 16,
    padding: 24,
    marginBottom: 16,
  },
  cardTitle: {
    fontSize: 20,
    fontWeight: '600',
    color: '#ffffff',
    marginTop: 16,
  },
  cardDesc: {
    fontSize: 14,
    color: '#6b7280',
    marginTop: 8,
  },
});`
    },
    {
      path: 'screens/DetailsScreen.tsx',
      type: 'typescript',
      content: `import React from 'react';
import { View, Text, StyleSheet } from 'react-native';
import { SafeAreaView } from 'react-native-safe-area-context';

export default function DetailsScreen() {
  return (
    <SafeAreaView style={styles.container}>
      <View style={styles.content}>
        <Text style={styles.title}>Details</Text>
        <Text style={styles.description}>
          This screen was generated by CapyCode AI.
          You can customize it to show any content you want.
        </Text>
      </View>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: '#0a0a0b',
  },
  content: {
    flex: 1,
    padding: 24,
    justifyContent: 'center',
    alignItems: 'center',
  },
  title: {
    fontSize: 28,
    fontWeight: 'bold',
    color: '#ffffff',
    marginBottom: 16,
  },
  description: {
    fontSize: 16,
    color: '#6b7280',
    textAlign: 'center',
    lineHeight: 24,
  },
});`
    },
    {
      path: 'components/Button.tsx',
      type: 'typescript',
      content: `import React from 'react';
import { TouchableOpacity, Text, StyleSheet, ActivityIndicator } from 'react-native';

interface ButtonProps {
  title: string;
  onPress: () => void;
  loading?: boolean;
  variant?: 'primary' | 'secondary';
}

export default function Button({ title, onPress, loading, variant = 'primary' }: ButtonProps) {
  return (
    <TouchableOpacity
      style={[styles.button, variant === 'secondary' && styles.secondary]}
      onPress={onPress}
      disabled={loading}
    >
      {loading ? (
        <ActivityIndicator color="#ffffff" />
      ) : (
        <Text style={styles.text}>{title}</Text>
      )}
    </TouchableOpacity>
  );
}

const styles = StyleSheet.create({
  button: {
    backgroundColor: '#10b981',
    paddingVertical: 16,
    paddingHorizontal: 24,
    borderRadius: 12,
    alignItems: 'center',
  },
  secondary: {
    backgroundColor: '#1f1f23',
  },
  text: {
    color: '#ffffff',
    fontSize: 16,
    fontWeight: '600',
  },
});`
    },
    {
      path: 'package.json',
      type: 'json',
      content: `{
  "name": "${appName.toLowerCase()}",
  "version": "1.0.0",
  "main": "node_modules/expo/AppEntry.js",
  "scripts": {
    "start": "expo start",
    "android": "expo start --android",
    "ios": "expo start --ios",
    "web": "expo start --web"
  },
  "dependencies": {
    "expo": "~50.0.0",
    "expo-status-bar": "~1.11.1",
    "react": "18.2.0",
    "react-native": "0.73.2",
    "@react-navigation/native": "^6.1.9",
    "@react-navigation/native-stack": "^6.9.17",
    "react-native-safe-area-context": "4.8.2",
    "react-native-screens": "~3.29.0",
    "@expo/vector-icons": "^14.0.0"
  },
  "devDependencies": {
    "@babel/core": "^7.20.0",
    "@types/react": "~18.2.45",
    "typescript": "^5.1.3"
  }
}`
    },
    {
      path: 'app.json',
      type: 'json',
      content: `{
  "expo": {
    "name": "${appName}",
    "slug": "${appName.toLowerCase()}",
    "version": "1.0.0",
    "orientation": "portrait",
    "icon": "./assets/icon.png",
    "userInterfaceStyle": "dark",
    "splash": {
      "image": "./assets/splash.png",
      "resizeMode": "contain",
      "backgroundColor": "#0a0a0b"
    },
    "ios": {
      "supportsTablet": true,
      "bundleIdentifier": "com.capycode.${appName.toLowerCase()}"
    },
    "android": {
      "adaptiveIcon": {
        "foregroundImage": "./assets/adaptive-icon.png",
        "backgroundColor": "#0a0a0b"
      },
      "package": "com.capycode.${appName.toLowerCase()}"
    }
  }
}`
    },
    {
      path: 'tsconfig.json',
      type: 'json',
      content: `{
  "extends": "expo/tsconfig.base",
  "compilerOptions": {
    "strict": true
  }
}`
    }
  ];
};

// Simulate realistic generation progress
const simulateGeneration = async (
  prompt: string,
  onProgress: (progress: GenerationProgress) => void,
  onFile: (file: GeneratedFile) => void
): Promise<GenerateResult> => {
  const files = generateDemoFiles(prompt);
  const stages = [
    { stage: 'analyzing' as const, message: 'Analyzing your requirements...', progress: 10 },
    { stage: 'analyzing' as const, message: 'Understanding app architecture...', progress: 20 },
    { stage: 'generating' as const, message: 'Generating project structure...', progress: 30 },
  ];

  // Progress through initial stages
  for (const stage of stages) {
    onProgress(stage);
    await new Promise(r => setTimeout(r, 800));
  }

  // Generate files one by one
  for (let i = 0; i < files.length; i++) {
    const file = files[i];
    const progress = 35 + ((i + 1) / files.length) * 55;
    
    onProgress({
      stage: 'generating',
      message: `Creating ${file.path}...`,
      progress,
      currentFile: file.path,
    });
    
    await new Promise(r => setTimeout(r, 600));
    onFile(file);
  }

  // Final stages
  onProgress({
    stage: 'building',
    message: 'Installing dependencies...',
    progress: 92,
  });
  await new Promise(r => setTimeout(r, 1000));

  onProgress({
    stage: 'building',
    message: 'Preparing preview...',
    progress: 97,
  });
  await new Promise(r => setTimeout(r, 500));

  onProgress({
    stage: 'complete',
    message: 'Your app is ready!',
    progress: 100,
  });

  const appName = prompt.toLowerCase().includes('fitness') ? 'FitnessApp' : 
                  prompt.toLowerCase().includes('social') ? 'SocialApp' :
                  prompt.toLowerCase().includes('calculator') ? 'CalculatorApp' : 'MyApp';

  return {
    files,
    dependencies: {
      'expo': '~50.0.0',
      'react': '18.2.0',
      'react-native': '0.73.2',
    },
    devDependencies: {
      'typescript': '^5.1.3',
    },
    expoConfig: {
      name: appName,
      slug: appName.toLowerCase(),
    },
  };
};

export function useGenerateProject(options: UseGenerateProjectOptions = {}) {
  const { streaming = false, onSuccess, onError, demoMode = false, model = 'gemini-2.5-flash' } = options;
  const { setProject, addFile, setLoading, reset: resetProjectStore, project } = useProjectStore();
  
  const [progress, setProgress] = useState<GenerationProgress>({
    stage: 'analyzing',
    message: 'Ready to generate',
    progress: 0,
  });
  const [streamedFiles, setStreamedFiles] = useState<GeneratedFile[]>([]);
  const [currentModel, setCurrentModel] = useState<AIModel>(model);

  // Function to generate with real AI API
  const generateWithAI = async (prompt: string, selectedModel: AIModel, userApiKey?: string, provider?: string, autoSelectKey?: boolean, userId?: string, isEdit?: boolean): Promise<GenerateResult> => {
    // Get current project for edit mode
    const currentProject = useProjectStore.getState().project;
    const existingFiles = isEdit && currentProject?.files ? currentProject.files : [];
    
    setProgress({
      stage: 'analyzing',
      message: isEdit ? 'Analyzing existing project...' : 'Analyzing your requirements...',
      progress: 10,
    });
    
    await new Promise(r => setTimeout(r, 500));
    
    // If editing, show what files we're reviewing
    if (isEdit && existingFiles.length > 0) {
      setProgress({
        stage: 'analyzing',
        message: `Reviewing ${existingFiles.length} existing files...`,
        progress: 15,
      });
      await new Promise(r => setTimeout(r, 500));
    }
    
    setProgress({
      stage: 'analyzing',
      message: autoSelectKey ? 'Finding the best API key...' : 'Connecting to AI...',
      progress: 20,
    });
    
    // Build context with existing files for edit mode
    let contextPrompt = prompt;
    if (isEdit && existingFiles.length > 0) {
      const filesSummary = existingFiles.map(f => `- ${f.path}`).join('\n');
      const mainFiles = existingFiles
        .filter(f => f.path.includes('App.tsx') || f.path.includes('index.tsx') || f.path.includes('screens/'))
        .slice(0, 3)
        .map(f => `\n--- ${f.path} ---\n${f.content.substring(0, 1000)}${f.content.length > 1000 ? '...' : ''}`);
      
      contextPrompt = `EXISTING PROJECT CONTEXT:
Files in project:
${filesSummary}

Key file contents:
${mainFiles.join('\n')}

USER REQUEST: ${prompt}

Please modify the existing project based on the user's request. Keep existing functionality and only change what's needed.`;
    }
    
    // Call our API route
    const requestBody = { 
      prompt: contextPrompt, 
      model: selectedModel,
      apiKey: userApiKey, // Pass user's API key if provided
      provider: provider, // Provider of the API key (google, openai, anthropic)
      autoSelectKey: autoSelectKey || false,
      userId: userId,
    };
    
    console.log('[useGenerateProject] Calling /api/generate with:', {
      prompt: prompt.substring(0, 50) + '...',
      model: selectedModel,
      hasApiKey: !!userApiKey,
      provider: provider,
      autoSelectKey: autoSelectKey,
      hasUserId: !!userId,
      isEdit: isEdit,
      existingFilesCount: existingFiles.length,
    });
    
    const response = await fetch('/api/generate', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(requestBody),
    });
    
    console.log('[useGenerateProject] Response status:', response.status);
    
    if (!response.ok) {
      const error = await response.json().catch(() => ({}));
      console.error('[useGenerateProject] API Error:', error);
      throw new Error(error.error || 'Failed to generate project');
    }
    
    setProgress({
      stage: 'generating',
      message: 'AI is creating your app...',
      progress: 50,
    });
    
    const result = await response.json();
    
    console.log('[useGenerateProject] API Result:', {
      filesCount: result.files?.length,
      hasExpoConfig: !!result.expoConfig,
      firstFile: result.files?.[0]?.path,
      expoName: result.expoConfig?.name,
      isEdit: isEdit
    });
    
    // Create initial project structure only if not editing
    const projectName = typeof result.expoConfig?.name === 'string' 
      ? result.expoConfig.name 
      : currentProject?.name || 'New Project';
    const projectSlug = typeof result.expoConfig?.slug === 'string'
      ? result.expoConfig.slug
      : currentProject?.slug || 'new-project';
    
    // Only create new project if not editing
    if (!isEdit) {
      setProject({
        id: crypto.randomUUID(),
        name: projectName,
        slug: projectSlug,
        description: '',
        files: [], // Start empty, files will be added progressively
        expo_config: result.expoConfig || {},
        dependencies: result.dependencies || {},
        dev_dependencies: result.devDependencies || {},
        status: 'generating',
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString(),
      });
    }
    
    // Stream files one by one for visual effect AND add/update to project store
    for (let i = 0; i < result.files.length; i++) {
      const file = result.files[i];
      setProgress({
        stage: 'generating',
        message: isEdit ? `Updating ${file.path}...` : `Creating ${file.path}...`,
        progress: 50 + ((i + 1) / result.files.length) * 40,
        currentFile: file.path,
      });
      setStreamedFiles(prev => [...prev, file]);
      
      // Check if file exists in current project (for edit mode)
      const existingFile = currentProject?.files?.find(f => f.path === file.path);
      if (existingFile) {
        // Update existing file
        useProjectStore.getState().updateFileContent(file.path, file.content);
      } else {
        // Add new file
        addFile(file);
      }
      
      // Delay between files for visual feedback (longer for better UX)
      await new Promise(r => setTimeout(r, 300));
    }
    
    setProgress({
      stage: 'building',
      message: 'Preparing preview...',
      progress: 95,
    });
    
    await new Promise(r => setTimeout(r, 500));
    
    setProgress({
      stage: 'complete',
      message: isEdit ? 'Project updated!' : 'Your app is ready!',
      progress: 100,
    });
    
    return result;
  };

  const mutation = useMutation({
    mutationFn: async (promptOrConfig: string | { prompt: string; model: AIModel; name?: string; description?: string; apiKey?: string; provider?: string; autoSelectKey?: boolean; userId?: string; isEdit?: boolean }) => {
      setLoading(true);
      setStreamedFiles([]);
      
      const prompt = typeof promptOrConfig === 'string' ? promptOrConfig : promptOrConfig.prompt;
      const selectedModel = typeof promptOrConfig === 'string' ? currentModel : promptOrConfig.model;
      const userApiKey = typeof promptOrConfig === 'string' ? undefined : promptOrConfig.apiKey;
      const provider = typeof promptOrConfig === 'string' ? undefined : promptOrConfig.provider;
      const autoSelectKey = typeof promptOrConfig === 'string' ? false : promptOrConfig.autoSelectKey;
      const userId = typeof promptOrConfig === 'string' ? undefined : promptOrConfig.userId;
      const isEdit = typeof promptOrConfig === 'string' ? false : promptOrConfig.isEdit;
      
      // Only reset project for new generation, not for edits
      if (!isEdit) {
        resetProjectStore();
      }
      
      if (typeof promptOrConfig !== 'string') {
        setCurrentModel(selectedModel);
      }
      
      // Use real AI generation - throw error if it fails (no more silent fallback)
      try {
        return await generateWithAI(prompt, selectedModel, userApiKey, provider, autoSelectKey, userId, isEdit);
      } catch (error: any) {
        console.error('AI generation failed:', error);
        // Re-throw to show error to user instead of silently falling back to demo
        throw error;
      }
    },
    onSuccess: (result) => {
      setLoading(false);
      setProgress({
        stage: 'complete',
        message: 'Generation complete!',
        progress: 100,
      });
      
      // Log generation to database
      const promptText = typeof mutation.variables === 'string' 
        ? mutation.variables 
        : mutation.variables?.prompt;
      logGeneration(promptText, 'completed').catch(console.error);
      
      // Get current project from store - files were already added progressively
      const currentProject = useProjectStore.getState().project;
      
      if (currentProject) {
        // Just update the status to 'active' - files are already there
        setProject({
          ...currentProject,
          status: 'active',
          updated_at: new Date().toISOString(),
        });
      }
      
      onSuccess?.(result);
    },
    onError: (error: Error) => {
      setLoading(false);
      setProgress({
        stage: 'analyzing',
        message: 'Generation failed',
        progress: 0,
      });
      
      // Log failed generation
      const promptText = typeof mutation.variables === 'string' 
        ? mutation.variables 
        : mutation.variables?.prompt;
      logGeneration(promptText, 'failed').catch(console.error);
      
      onError?.(error);
    },
  });

  const generateProject = useCallback(
    async (promptOrConfig: string | { prompt: string; model: AIModel; name?: string; description?: string; apiKey?: string; provider?: string; autoSelectKey?: boolean; userId?: string; isEdit?: boolean }) => {
      return await mutation.mutateAsync(promptOrConfig);
    },
    [mutation]
  );

  const generateWithConfig = useCallback(
    async (config: { prompt: string; model: AIModel; name?: string; description?: string; apiKey?: string; provider?: string; autoSelectKey?: boolean; userId?: string; isEdit?: boolean }) => {
      return await mutation.mutateAsync(config);
    },
    [mutation]
  );

  const reset = useCallback(() => {
    mutation.reset();
    setProgress({
      stage: 'analyzing',
      message: 'Ready to generate',
      progress: 0,
    });
    setStreamedFiles([]);
  }, [mutation]);

  return {
    generateProject,
    generateWithConfig,
    isGenerating: mutation.isPending,
    progress,
    streamedFiles,
    error: mutation.error,
    reset,
    currentModel,
    setCurrentModel,
  };
}

interface UseGenerateComponentOptions {
  projectId: string;
  onSuccess?: (file: GeneratedFile) => void;
  onError?: (error: Error) => void;
}

export function useGenerateComponent(options: UseGenerateComponentOptions) {
  const { projectId, onSuccess, onError } = options;
  const { addFile } = useProjectStore();

  const mutation = useMutation({
    mutationFn: async (prompt: string) => {
      const result = await api.generateComponent(prompt, projectId);
      return result.component;
    },
    onSuccess: (file) => {
      addFile(file);
      onSuccess?.(file);
    },
    onError,
  });

  const generateComponent = useCallback(
    (prompt: string) => {
      mutation.mutate(prompt);
    },
    [mutation]
  );

  return {
    generateComponent,
    isGenerating: mutation.isPending,
    error: mutation.error,
    reset: mutation.reset,
  };
}
